# JavaScript

## 闭包
- 闭包就是能够读取其他函数内部变量的函数
- 闭包是指有权访问另⼀个函数作⽤域中变量的函数，创建闭包的最常⻅的⽅式就是在⼀个
- 函数内创建另⼀个函数，通过另⼀个函数访问这个函数的局部变量,利⽤闭包可以突破作⽤
- 链域
- 闭包的特性：
    - 函数内再嵌套函数
    - 内部函数可以引⽤外层的参数和变量
    - 参数和变量不会被垃圾回收机制回收
### 说说你对闭包的理解

- 使⽤闭包主要是为了设计私有的⽅法和变量。闭包的优点是可以避免全局变量的污染，缺
- 点是闭包会常驻内存，会增⼤内存使⽤量，使⽤不当很容易造成内存泄露。在js中，函数即
- 闭包，只有函数才会产⽣作⽤域的概念
- 闭包 的最⼤⽤处有两个，⼀个是可以读取函数内部的变量，另⼀个就是让这些变量始终保
- 持在内存中
- 闭包的另⼀个⽤处，是封装对象的私有属性和私有⽅法
- 好处：能够实现封装和缓存等；
- 坏处：就是消耗内存、不正当使⽤会造成内存溢出的问题
### 使⽤闭包的注意点

- 由于闭包会使得函数中的变量都被保存在内存中，内存消耗很⼤，所以不能滥⽤闭包，否则会造成⽹⻚的性能问题，在IE中可能导致内存泄露
- 解决⽅法是，在退出函数之前，将不使⽤的局部变量全部删除

## 说说你对作⽤域链的理解

- 作⽤域链的作⽤是保证执⾏环境⾥有权访问的变量和函数是有序的，作⽤域链的变量只能向上访问，变量访问到 **window** 对象即被终⽌，作⽤域链向下访问变量是不被允许的
- 简单的说，作⽤域就是变量与函数的可访问范围，即作⽤域控制着变量与函数的可⻅性和⽣命周期

## JavaScript原型，原型链 ? 有什么特点？
- 每个对象都会在其内部初始化⼀个属性，就是 **prototype** (原型)，当我们访问⼀个对象的属性时
- 如果这个对象内部不存在这个属性，那么他就会去 prototype ⾥找这个属性，这个prototype ⼜会有⾃⼰的 prototype ，于是就这样⼀直找下去，也就是我们平时所说的原型链的概念
-  关系： instance.constructor.prototype = instance.__proto__
- 特点：
    - JavaScript 对象是通过引⽤来传递的，我们创建的每个新对象实体中并没有⼀份属于⾃⼰的原型副本。当我们修改原型时，与之相关的对象也会继承这⼀改变
- 当我们需要⼀个属性的时， Javascript 引擎会先看当前对象中是否有这个属性， 如果没有的
- 就会查找他的 Prototype 对象是否有这个属性，如此递推下去，⼀直检索到 Object 内建对象

## 请解释什么是事件代理

- 事件代理（ **Event Delegation** ），⼜称之为**事件委托**。是 JavaScript 中常⽤绑定事件的常⽤技巧。顾名思义，“事件代理”即是**把原本需要绑定的事件委托给⽗元素，让⽗元素担当事件监听的职务**。
- 事件代理的原理是DOM元素的**事件冒泡**。使⽤事件代理的好处是可以提⾼性能
- 可以⼤量节省内存占⽤，**减少事件注册**，⽐如在 table 上代理所有 td 的 click 事件就⾮常棒
- 可以实现当新增⼦对象时⽆需再次对其绑定
## ❤ Javascript如何实现继承？

### 构造继承
-   特点：
    - 创建子类实例时，可以向父类传递参数
    - 可以实现多继承（call多个父类对象）
- 缺点：
    - 实例并不是父类的实例，只是子类的实例
    - 只能 <ofont>继承父类的实例属性和方法，不能继承原型属性/方法</ofont> 
    - 无法实现函数复用，每个子类都有父类实例函数的副本，影响性能
:::demo 构造继承
js/extendCot
:::
### 原型继承
- 特点：
    - 非常纯粹的继承关系，**实例是子类的实例，也是父类的实例**
    - 父类新增原型方法/原型属性，子类都能访问到
    - 简单，易于实现
- 缺点：
    - 要想为子类新增属性和方法，可以在Cat构造函数中，为Cat实例增加实例属性。如果要新增原型属性和方法，则必须放在new Animal()这样的语句之后执行。
    - 无法实现多继承
    - 来自原型对象的所有属性被所有实例共享
    - 创建子类实例时，无法向父类构造函数传参
:::demo 构造继承
js/extendPro
:::

###  实例继承
- 核心：为父类实例添加新特性，作为子类实例返回
- 特点：
    - 不限制调用方式，不管是new 子类()还是子类(),返回的对象具有相同的效果
- 缺点：
    - 实例是父类的实例，不是子类的实例
    - 不支持多继承
:::demo 构造继承
js/extendIns
:::

### 拷⻉继承
- 支持多继承
- 缺点：
    - 效率较低，内存占用高（因为要拷贝父类的属性）
    - 无法获取父类不可枚举的方法（不可枚举方法，不能使用for in 访问到）
:::demo 拷⻉继承
js/extendCopy
:::

### 组合继承
- 核心：通过调用父类构造，继承父类的属性并保留传参的优点，然后通过将父类实例作为子类原型，实现函数复用
- 特点：
    - 弥补了方式2的缺陷，可以继承实例属性/方法，也可以继承原型属性/方法
    - 既是子类的实例，也是父类的实例
    - 不存在引用属性共享问题
    - 可传参
    - 函数可复用
- 缺点：
    - 调用了两次父类构造函数，生成了两份实例（子类实例将子类原型上的那份屏蔽了）

:::demo 组合继承
js/extendGroup
:::
# http
## 谈一谈HTTP协议优缺点

超文本传输协议，**「HTTP 是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范」。**

### HTTP 特点
- **「灵活可扩展」**。一个是语法上只规定了基本格式，空格分隔单词，换行分隔字段等。另外一个就是传输形式上不仅可以传输文本，还可以传输图片，视频等任意数据。
- **「请求-应答模式」**，通常而言，就是一方发送消息，另外一方要接受消息，或者是做出相应等。
- **「可靠传输」**，HTTP是基于TCP/IP，因此把这一特性继承了下来。
- **「无状态」**，这个分场景回答即可。

### HTTP 缺点
- **「无状态」**，有时候，需要保存信息，比如像购物系统，需要保留下顾客信息等等，另外一方面，有时候，无状态也会减少网络开销，比如类似直播行业这样子等，这个还是分场景来说。
- **「明文传输」**，即协议里的报文(主要指的是头部)不使用二进制数据，而是文本形式。这让HTTP的报文信息暴露给了外界，给攻击者带来了便利。
- **「队头阻塞」**，当http开启长连接时，共用一个TCP连接，当某个请求时间过长时，其他的请求只能处于阻塞状态，这就是队头阻塞问题。
## HTTP 1.0
- 任何格式的内容都可以发送，这使得互联网不仅可以传输文字，还能传输图像、视频、二进制等文件。
- 除了GET命令，还引入了POST命令和HEAD命令。
- http请求和回应的格式改变，除了数据部分，每次通信都必须包括头信息（HTTP header），用来描述一些元数据。
- 只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。
- 不支持断点续传，也就是说，每次都会传送全部的页面和数据。
- 通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）
## HTTP 1.1
http1.1是目前最为主流的http协议版本，从1999年发布至今，仍是主流的http协议版本。

- 引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置
- 引入了**管道机制（ pipelining）**，即在同一个TCP连接里，客户端可以同时发送多个请求，进一步改进了HTTP协议的效率。
- HTTP 1.1 中新增加了 **E-tag，If-Unmodified-Since, If-Match, If-None-Match** 等缓存控制标头来控制缓存失效。
- 支持断点续传，通过使用请求头中的 **Range** 来实现。
- 使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
- 新增方法：PUT、 PATCH、 OPTIONS、 DELETE。

## http2.0 特性如下

- **二进制分帧**  这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。
- **头部压缩**  HTTP 1.1版本会出现 「User-Agent、Cookie、Accept、Server、Range」 等字段可能会占用几百甚至几千字节，而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进压缩。

那我们看看**HPACK算法**吧👇
![img2](./../img/http/1.png)
::: tip
从上面看，我们可以看到类似于索引表，每个索引表对应一个值，比如索引为2对应头部中的method头部信息，这样子的话，在传输的时候，不在是传输对应的头部信息了，而是传递索引，对于之前出现过的头部信息，只需要把「索引」(比如1，2，...)传给对方即可，对方拿到索引查表就行了。
:::

这种 **「传索引」**的方式，可以说让请求头字段得到极大程度的精简和复用。
其次是对于整数和字符串进行 **「哈夫曼编码」**，哈夫曼编码的原理就是先将所有出现的字符建立一张索引表，然后让**出现次数多的字符对应的索引尽可能短**，传输的时候也是传输这样的 **「索引序列」**，可以达到非常高的压缩率。
- **多路复用** 复用TCP连接，在一个连接里，客户端和浏览器都可以同时发送多个请求或回应，且不用按顺序一一对应，这样子解决了队头阻塞的问题。
    - HTTP 1.x 中，如果想并发多个请求，必须使用多个 TCP 链接，且浏览器为了控制资源，还会对单个域名有 6-8个的TCP链接请求限制。
    - HTTP2中：
        - 同域名下所有通信都在单个连接上完成。
        - 单个连接可以承载任意数量的双向数据流。
        - 数据流以消息的形式发送，而消息又由一个或多个帧组成，多个帧之间可以乱序发送，因为根据帧首部的流标识可以重新组装，也就是 **Stream ID，流标识符**，有了它，接收方就能从乱序的二进制帧中选择ID相同的帧，按照顺序组装成请求/响应报文。

- **服务器推送** 允许服务器未经请求，主动向客户端发送资源，即服务器推送。
    - 相比较http/1.1的优势👇
        - 推送资源可以由不同页面共享
        - 服务器可以按照优先级推送资源
        - 客户端可以缓存推送的资源
        - 客户端可以拒收推送过来的资源
- **请求优先级** 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。


## Http3.0 相对于 Http2.0 是一种脱胎换骨的改变！
http 协议是应用层协议，都是建立在传输层之上的。我们也都知道传输层上面不只有 TCP 协议，还有另外一个强大的协议 UDP 协议，2.0 和 1.0 都是基于 TCP 的，因此都会有 TCP 带来的硬伤以及局限性。而 Http3.0 则是建立在 UDP 的基础上。所以其与 Http2.0 之间有质的不同。
- http3.0 特性如下
    - 连接迁移
    - 无队头阻塞
    - 自定义的拥塞控制
    - 前向安全和前向纠错


[Http2.0 的一些思考以及 Http3.0 的优势](https://blog.csdn.net/m0_60360320/article/details/119812431)    


## 介绍一下Connection:keep-alive
### 什么是keep-alive

我们知道HTTP协议采用“请求-应答”模式，当使用普通模式，即非KeepAlive模式时，每个请求/应答客户和服务器都要新建一个连接，完成 之后立即断开连接（HTTP协议为无连接的协议）；


当使用Keep-Alive模式（又称持久连接、连接重用）时，Keep-Alive功能使客户端到服 务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接。

### 为什么要使用keep-alive

keep-alive技术的创建目的，能在多次**HTTP之前重用同一个TCP连接**，从而减少创建/关闭多个 TCP 连接的开销（包括响应时间、CPU 资源、减少拥堵等），参考如下示意图（来源：维基百科）：

![img](./../img/http/2.png)

### 客户端如何开启
- 在HTTP/1.0协议中，默认是关闭的，需要在http头加入"Connection: Keep-Alive”，才能启用Keep-Alive；

- http 1.1中默认启用Keep-Alive，如果加入"**Connection: close** “，才关闭。

目前大部分浏览器都是用http1.1协议，也就是说默认都会发起Keep-Alive的连接请求了，所以是否能完成一个完整的Keep- Alive连接就看服务器设置情况。



## options 方法有什么用？
- OPTIONS 请求与 HEAD 类似，一般也是用于客户端查看服务器的性能。
- 这个方法会请求服务器返回该资源所支持的所有 HTTP 请求方法，该方法会用'*'来代替资源名称，向服务器发送 OPTIONS 请求，可以测试服务器功能是否正常。
- JS 的 XMLHttpRequest对象进行 **CORS 跨域资源共享时**，对于复杂请求，就是使用 OPTIONS 方法发送**嗅探请求**，以判断是否有对指定资源的访问权限。
## 谈一谈队头阻塞问题
对于每一个HTTP请求而言，这些任务是会被放入一个任务队列中串行执行的，一旦队首任务请求太慢时，就会阻塞后面的请求处理，这就是**HTTP队头阻塞**问题。

### 并发连接
我们知道对于一个域名而言，是允许分配多个长连接的，那么可以理解成增加了任务队列，也就是说不会导致一个任务阻塞了该任务队列的其他任务，在**RFC规范**中规定客户端最多并发2个连接，不过实际情况就是要比这个还要多，举个例子，Chrome中是6个。

### 域名分片
顾名思义，我们可以在一个域名下分出多个二级域名出来，而它们最终指向的还是同一个服务器，这样子的话就可以并发处理的任务队列更多，也更好的解决了队头阻塞的问题。


